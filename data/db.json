{
  "posts": [
    {
      "title": "What you should know about React Hooks.",
      "body": "React Hooks were introduced in February 2019 and since then developers round the have been implementing interest. Using Hooks are way that allows writing functional components which provides access to new functionality that are only available if class components were written. Hooks cannot be used inside class components but can be used inside functional components. The useState hook allows for functional components to have access to internal state features that are only available if class components were implemented. It is a function that gets a parameter which is a value intended for the initial value of the state. It gives back an array with two values which are then destructed. The first is the state value that is of interest. The second is a function that allows setting of the first value. useEffect hook gives the ability to fire side effects inside functional components. It does not give anything back, it gets a function that gets called whenever the components changes, or updates and re-renders. useEffect takes a secondary parameter, an array which are properties that the effect as access to which will not trigger a re-render. An empty array, which can be passed as a second argument means do not re-render for any changes. useEffect cannot be called inside a conditional (eg. the If-else loop) rather at the top level of the component in which it is going to be implemented. If a conditional is to be leveraged, it should be put inside the useEffect hook. The useEffect hook allows for passing back function from a function parameter. The returned function from useEffect is called a cleanup function. A cleanup function is what useEffect calls when the component unmounts. There are other hooks such as useContext, useMemo, useCallback etc. I hope you enjoyed reading this piece. Suggestions are highly welcomed.",
      "likes": 10,
      "id": 1
    },
    {
      "title": "Chunking, Code Splitting, and Error Handling in React.",
      "body": "The Create-react-app gives code splitting and chunking features. Code splitting involves bundling up and serving the requested code for the particular page of the web application a user navigates to. This technique is a great way to optimize an app. A way to test optimization is through the Network tab in the Google developer tools. Serving up code files when needed is done through Dynamic importing. This means bringing in an import almost like a Promise ie. pulling in a file and loading it when necessary. React-Lazy helps achieve this. The intended component is wrapped in the lazy function provided by React and used in conjunction with react-router which by default supports code splitting. Suspense Feature in React Suspense is a component in React that allows wrapping part of an application that might be rendering asynchronous components. It takes a fallback property which takes in an HTML element or component itself. It can encapsulate multiple components while waiting, it renders the fallback until every component in it has finished lazy-loading. Error Boundary in React With chunking comes the dependency on the ISP network being active and fast whenever request is made to navigate new routes in an application. When this is done, fetching the JS chunk related to the route is done. If the connection suddenly stops or slows down and throws an error of some kind, the spinner will possibly hang and render indefinitely. If an error is returned, it needs to be handled as Suspense wouldn't know what to do with that error which might cause the app to break. To deal with this, an Error Boundary is used. An Error Boundary is a React feature which allows writing of a unique component that will catch an error and render some fallback component or UI instead of letting the error occur. An Error Boundary component is a class component that as either a componentDidCatch lifecycle method in it or a static getDerivedStateFromError method. The static getDerivedStateFromError is a method which essentially catches any error that gets thrown in any of the children of the error boundary component in which it is declared. It returns some object that will set the state inside the class component. The componentDidCatch which gives access to both the error and info related to the error and how it got thrown. Info might be which component threw the error. It also allows an operation to be done with the error such as logging it in the console. In conclusion, less JS makes the initial loading of an app faster and in cases where errors arises, React provides features to help handle it.",
      "likes": 20,
      "id": 2
    },
    {
      "title": "Software Testing",
      "body": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Orci eu lobortis elementum nibh tellus molestie nunc non blandit. Malesuada pellentesque elit eget gravida cum sociis natoque penatibus et. Purus non enim praesent elementum facilisis. Eu facilisis sed odio morbi quis commodo odio aenean sed. Phasellus egestas tellus rutrum tellus pellentesque eu tincidunt tortor aliquam. Ut aliquam purus sit amet luctus venenatis lectus magna fringilla. Amet luctus venenatis lectus magna. At augue eget arcu dictum varius duis at consectetur. Sed id semper risus in hendrerit gravida. Porttitor eget dolor morbi non arcu risus. Mauris ultrices eros in cursus turpis massa. Placerat orci nulla pellentesque dignissim enim. Diam maecenas ultricies mi eget mauris pharetra et ultrices.",
      "likes": 30,
      "id": 3
    }
  ]
}